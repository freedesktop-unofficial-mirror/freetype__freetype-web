<!DOCTYPE html PUBLIC
  "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
  <meta http-equiv="Content-Type"
        content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type"
        content="text/css" />
  <meta name="generator"
        content="pandoc" />
  <meta name="author"
        content="Werner Lemberg" />
  <meta name="version"
        content="0.95" />

  <title>ttfautohint</title>

  <style type="text/css">
    /* use Droid fonts */
    @import url("http://fonts.googleapis.com/css?family=Droid+Serif");
    @import url("http://fonts.googleapis.com/css?family=Droid+Sans+Mono");
  
    /* top-level appearance */
    body {
      width: 100%;
      margin: 0;
      padding: 0;
      border: 0;
      text-align: left;
      font-size: large;
      font-family: "Droid Serif", serif;
      line-height: 130%; }
  
    /* table of contents; */
    /* width and offsets must be synchronized with col2 below */
    #TOC {
      position: fixed;
      font-size: 115%;
      left: 0em;
      width: 13em; }
    /* don't display list markers in TOC */
    #TOC ul {
      list-style: none; }
    #TOC ul li {
      /* negative indentation for the first line of a TOC entry */
      text-indent: -1em;
      /* leave some vertical space between TOC entries */
      margin-bottom: 1ex; }
    /* only display first-level TOC entries */
    #TOC ul li ul {
      display: none; }
    /* no link color necessary for TOC entries */
    #TOC a {
      color: black; }
  
    /* column container */
    .colmask {
      /* this fixes the IE7 overflow hidden bug */
      /* and stops the layout jumping out of place */
      position: relative;
      clear: both;
      float: left;
      width: 100%;
      /* this chops off any overhanging `div's */
      overflow: hidden; }
    /* two-column left menu settings (col1 is right, col2 is left) */
    .leftmenu {
      background: white; }
    .leftmenu .colright {
      float: left;
      width: 200%;
      position: relative;
      left: 15em; /* pad2_l + wd2 + pad2_r */
      background: white; }
    .leftmenu .col1wrap {
      float: right;
      width: 50%;
      position: relative;
      right: 15em; /* pad2_l + wd2 + pad2_r */
      padding-bottom: 1em; }
    .leftmenu .col1 {
      margin: 0 1em   /* pad2_r */
              0 15em; /* pad2_l + wd2 + pad2_r + pad1_l */
      position: relative;
      right: 100%;
      width: 45em;
      max-width: 66%;
      /* overflow: hidden; */ }
    .leftmenu .col2 {
      float: left;
      width: 13em; /* wd2 */
      position: relative;
      right: 14em; } /* wd2 + pad2_r */
  
    blockquote {
      font-style: italic;
    }
  
    code {
      font-family: "Droid Sans Mono", monospace; }
    /* no underline for links */
    a {
      text-decoration: none; }
  
    h1 {
      margin-top: 3.5ex; }
    h2 {
      margin-top: 3ex; }
    h3 {
      margin-top: 2.5ex; }
    h4 { }
    h5 { }
    h6 { }
    h1.title {
     text-align: center; }
    h2.author {
     text-align: center; }
    h3.date {
     text-align: center; }
    /* since we have a TOC at a fixed position, */
    /* links in headers back to the TOC are unnecessary */
    h1 a,
    h2 a,
    h3 a,
    h4 a,
    h5 a,
    h6 a {
      color: black; }
  
    /* figures */
    div.figure {
      text-align: center;
      margin-top: 5ex;
      margin-bottom: 5ex; }
    p.caption {
      font-size: smaller; }
  
    /* tables */
    table {
      border-collapse: collapse;
      /* the next two lines center the table horizontally */
      margin-left: auto;
      margin-right: auto;
      margin-top: 5ex;
      margin-bottom: 5ex; } 
    td {
      padding-left: 0.8em;
      padding-right: 0.8em; }
    thead {
      /* a horizontal rule between table head and body */
      border-bottom: solid thin; }
    th {
      padding-left: 0.8em;
      padding-right: 0.8em;
      /* some vertical space before the horizontal rule */
      padding-bottom: 1ex; }
    tbody tr:first-child td {
      /* some vertical space after the horizontal rule */
      padding-top: 1ex; }
  
    /* if we have paragraphs in definition lists, */
    /* suppress the very first vertical space */
    dd > p:first-child {
      margin-top: 0; }
  
    /* source-code highlighting */
    table.sourceCode,
    tr.sourceCode,
    td.lineNumbers,
    td.sourceCode,
    table.sourceCode pre {
      margin: 0;
      padding: 0;
      border: 0;
      vertical-align: baseline;
      border: none; }
    td.lineNumbers {
      border-right: 1px solid #AAAAAA;
      text-align: right;
      color: #AAAAAA;
      padding-right: 5px;
      padding-left: 5px; }
    td.sourceCode {
      padding-left: 5px; }
  
    pre.sourceCode {
      margin-left: 2em; }
  
    code.sourceCode span.kw {
      color: #007020;
      font-weight: bold; }
    code.sourceCode span.dt {
      color: #902000; }
    code.sourceCode span.dv {
      color: #40a070; }
    code.sourceCode span.bn {
      color: #40a070; }
    code.sourceCode span.fl {
      color: #40a070; }
    code.sourceCode span.ch {
      color: #4070a0; }
    code.sourceCode span.st {
      color: #4070a0; }
    code.sourceCode span.co {
      color: #60a0b0;
      font-style: italic; }
    code.sourceCode span.ot {
      color: #007020; }
    code.sourceCode span.al {
      color: red;
      font-weight: bold; }
    code.sourceCode span.fu {
      color: #06287e; }
    code.sourceCode span.re { }
    code.sourceCode span.er {
      color: red;
      font-weight: bold; }
  </style>
</head>

<body>

<div class="colmask leftmenu">
  <div class="colright">
    <div class="col1wrap">
      <div class="col1">
<div id="header">
<h1 class="title">ttfautohint</h1>
<h2 class="author">Werner Lemberg</h2>
<h3 class="date">Version 0.95</h3>
</div>

<!--
  Copyright (C) 2011-2013 by Werner Lemberg.

  This file is part of the ttfautohint library, and may only be used,
  modified, and distributed under the terms given in `COPYING'.  By
  continuing to use, modify, or distribute this file you indicate that you
  have read `COPYING' and understand and accept it fully.

  The file `COPYING' mentioned in the previous paragraph is distributed
  with the ttfautohint library.
-->



<h1 id="introduction"><a href="#TOC">Introduction</a></h1>
<p><strong>ttfautohint</strong> is a library written in C which takes a TrueType font as the input, removes its bytecode instructions (if any), and returns a new font where all glyphs are bytecode hinted using the information given by FreeType’s autohinting module. The idea is to provide the excellent quality of the autohinter on platforms which don’t use FreeType.</p>
<p>The library has a single API function, <code>TTF_autohint</code>, which is described <a href="#the-ttfautohint-api">below</a>.</p>
<p>Bundled with the library there are two front-end programs, <a href="#ttfautohint-and-ttfautohintgui"><code>ttfautohint</code> and <code>ttfautohintGUI</code></a>, being a command line and an application with a Graphics User Interface (GUI), respectively.</p>
<h2 id="what-exactly-are-hints"><a href="#TOC">What exactly are hints?</a></h2>
<p>To cite <a href="http://en.wikipedia.org/wiki/Font_hinting">Wikipedia</a>:</p>
<blockquote>
<p><strong>Font hinting</strong> (also known as <strong>instructing</strong>) is the use of mathematical instructions to adjust the display of an outline font so that it lines up with a rasterized grid. At low screen resolutions, hinting is critical for producing a clear, legible text. It can be accompanied by antialiasing and (on liquid crystal displays) subpixel rendering for further clarity.</p>
</blockquote>
<p>and Apple’s <a href="https://developer.apple.com/fonts/TTRefMan/RM03/Chap3.html#features">TrueType Reference Manual</a>:</p>
<blockquote>
<p>For optimal results, a font instructor should follow these guidelines:</p>
<ul>
<li><p>At small sizes, chance effects should not be allowed to magnify small differences in the original outline design of a glyph.</p></li>
<li><p>At large sizes, the subtlety of the original design should emerge.</p></li>
</ul>
</blockquote>
<p>In general, there are three possible ways to hint a glyph.</p>
<ol style="list-style-type: decimal">
<li><p>The font contains hints (in the original sense of this word) to guide the rasterizer, telling it which shapes of the glyphs need special consideration. The hinting logic is partly in the font and partly in the rasterizer. More sophisticated rasterizers are able to produce better rendering results.</p>
<p>This is how Type 1 and CFF font hints work.</p></li>
<li><p>The font contains exact instructions (also called <em>bytecode</em>) on how to move the points of its outlines, depending on the resolution of the output device, and which intentionally distort the (outline) shape to produce a well-rasterized result. The hinting logic is in the font; ideally, all rasterizers simply process these instructions to get the same result on all platforms.</p>
<p>This is how TrueType hints work.</p></li>
<li><p>The font gets auto-hinted (at run-time). The hinting logic is completely in the rasterizer. No hints in the font are used or needed; instead, the rasterizer scans and analyzes the glyphs to apply corrections by itself.</p>
<p>This is how FreeType’s auto-hinter works; see <a href="#background-and-technical-details">below</a> for more.</p></li>
</ol>
<h2 id="what-problems-can-arise-with-truetype-hinting"><a href="#TOC">What problems can arise with TrueType hinting?</a></h2>
<p>While it is relatively easy to specify PostScript hints (either manually or by an auto-hinter which works at font creation time), creating TrueType hints is far more difficult. There are at least two reasons:</p>
<ul>
<li><p>TrueType instructions form a programming language, operating at a very low level. They are comparable to assembler code, thus lacking all high-level concepts to make programming more comfortable.</p>
<p>Here an example how such code looks like:</p>
<pre><code>    SVTCA[0]
    PUSHB[ ]  /* 3 values pushed */
    18 1 0
    CALL[ ]
    PUSHB[ ]  /* 2 values pushed */
    15 4
    MIRP[01001]
    PUSHB[ ]  /* 3 values pushed */
    7 3 0
    CALL[ ]</code></pre>
<p>Another major obstacle is the fact that font designers usually aren’t programmers.</p></li>
<li><p>It is very time consuming to manually hint glyphs. Given that the number of specialists for TrueType hinting is very limited, hinting a large set of glyphs for a font or font family can become very expensive.</p></li>
</ul>
<h2 id="why-ttfautohint"><a href="#TOC">Why ttfautohint?</a></h2>
<p>The ttfautohint library brings the excellent quality of FreeType rendering to platforms which don’t use FreeType, yet require hinting for text to look good – like Microsoft Windows. Roughly speaking, it converts the glyph analysis done by FreeType’s auto-hinting module to TrueType bytecode. Internally, the auto-hinter’s algorithm resembles PostScript hinting methods; it thus combines all three hinting methods discussed <a href="#what-exactly-are-hints">previously</a>.</p>
<p>The simple interface of the front-ends (both on the command line and with the GUI) allows quick hinting of a whole font with a few mouse clicks or a single command on the prompt. As a result, you get better rendering results with web browsers, for example.</p>
<p>Across Windows rendering environments today, fonts processed with ttfautohint look best with ClearType enabled. This is the default for Windows 7. Good visual results are also seen in recent MacOS X versions and GNU/Linux systems that use FreeType for rendering.</p>
<p>The goal of the project is to generate a ‘first pass’ of hinting that font developers can refine further for ultimate quality.</p>
<h1 id="ttfautohint-and-ttfautohintgui"><a href="#TOC"><code>ttfautohint</code> and <code>ttfautohintGUI</code></a></h1>
<p>On all supported platforms (GNU/Linux, Windows, and Mac OS X), the GUI looks quite similar; the used toolkit is <a href="http://qt-project.org">Qt</a>, which in turn uses the platform’s native widgets.</p>
<div class="figure">
<img src="img/ttfautohintGUI.png" alt="ttfautohintGUI on GNU/Linux running KDE" /><p class="caption"><code>ttfautohintGUI</code> on GNU/Linux running KDE</p>
</div>
<p>Both the GUI and console version share the same features, to be discussed in the next subsection.</p>
<p><strong>Warning: ttfautohint cannot always process a font a second time.</strong> If the font contains composite glyphs, and option <code>-c</code> is not used, reprocessing with ttfautohint will fail. For this reason it is strongly recommended to <em>not</em> delete the original, unhinted font so that you can always rerun ttfautohint.</p>
<h2 id="calling-ttfautohint"><a href="#TOC">Calling <code>ttfautohint</code></a></h2>
<pre><code>    ttfautohint [OPTION]... [IN-FILE [OUT-FILE]]</code></pre>
<p>The TTY binary, <code>ttfautohint</code>, works like a Unix filter, this is, it reads data from standard input if no input file name is given, and it sends its output to standard output if no output file name is specified.</p>
<p>A typical call looks like the following.</p>
<pre><code>    ttfautohint -v -f foo.ttf foo-autohinted.ttf</code></pre>
<p>For demonstration purposes, here the same using a pipe and redirection. Note that Windows’s default command line interpreter, <code>cmd.exe</code>, doesn’t support piping with binary files, unfortunately.</p>
<pre><code>    cat foo.ttf | ttfautohint -v -f &gt; foo-autohinted.ttf</code></pre>
<h2 id="calling-ttfautohintgui"><a href="#TOC">Calling <code>ttfautohintGUI</code></a></h2>
<pre><code>    ttfautohintGUI [OPTION]...</code></pre>
<p><code>ttfautohintGUI</code> doesn’t send any output to a console; however, it accepts the same command line options as <code>ttfautohint</code>, setting default values for the GUI.</p>
<h2 id="options"><a href="#TOC">Options</a></h2>
<p>Long options can be given with one or two dashes, and with and without an equal sign between option and argument. This means that the following forms are acceptable: <code>-foo=</code><em>bar</em>, <code>--foo=</code><em>bar</em>, <code>-foo</code> <em>bar</em>, and <code>--foo</code> <em>bar</em>.</p>
<p>Below, the section title refers to the command’s label in the GUI, then comes the name of the corresponding long command line option and its short equivalent, followed by a description.</p>
<p>Background and technical details on the meaning of the various options are given <a href="#background-and-technical-details">afterwards</a>.</p>
<h3 id="hint-set-range-minimum-hint-set-range-maximum"><a href="#TOC">Hint Set Range Minimum, Hint Set Range Maximum</a></h3>
<p>See <a href="#hint-sets">‘Hint Sets’</a> for a definition and explanation.</p>
<dl>
<dt><code>--hinting-range-min=</code><em>n</em>, <code>-l</code> <em>n</em></dt>
<dd><p>The minimum PPEM value (in pixels) at which hint sets are created. The default value for <em>n</em> is 8.</p>
</dd>
<dt><code>--hinting-range-max=</code><em>n</em>, <code>-r</code> <em>n</em></dt>
<dd><p>The maximum PPEM value (in pixels) at which hint sets are created. The default value for <em>n</em> is 50.</p>
</dd>
</dl>
<h3 id="fallback-script"><a href="#TOC">Fallback Script</a></h3>
<dl>
<dt><code>--latin-fallback</code>, <code>-f</code></dt>
<dd>Set fallback script to ‘latin’, this is, use the ‘latin’ auto-hinting module instead of ‘none’ for all glyphs which can’t be assigned to a script. See <a href="#scripts">below</a> for more details.
</dd>
</dl>
<h3 id="hinting-limit"><a href="#TOC">Hinting Limit</a></h3>
<dl>
<dt><code>--hinting-limit=</code><em>n</em>, <code>-G</code> <em>n</em></dt>
<dd><p>The <em>hinting limit</em> is the PPEM value (in pixels) where hinting gets switched off (using the <code>INSTCTRL</code> bytecode instruction); it has zero impact on the file size. The default value for <em>n</em> is 200 which means that the font is not hinted for PPEM values larger than 200.</p>
<p>Note that hinting in the range ‘hinting-range-max’ up to ‘hinting-limit’ uses the hinting configuration for ‘hinting-range-max’.</p>
<p>To omit a hinting limit, use <code>--hinting-limit=0</code> (or check the ‘No Hinting Limit’ box in the GUI). Since this will cause internal math overflow in the rasterizer for large pixel values (&gt; 1500px approx.) it is strongly recommended to not use this except for testing purposes.</p>
</dd>
</dl>
<h3 id="x-height-increase-limit"><a href="#TOC">x Height Increase Limit</a></h3>
<dl>
<dt><code>--increase-x-height=</code><em>n</em>, <code>-x</code> <em>n</em></dt>
<dd><p>Normally, ttfautohint rounds the x height to the pixel grid, with a slight preference for rounding up. If this flag is set, values in the range 6 PPEM to <em>n</em> PPEM are much more often rounded up. The default value for <em>n</em> is 14. Use this flag to increase the legibility of small sizes if necessary; you might get weird rendering results otherwise for glyphs like ‘a’ or ‘e’, depending on the font design.</p>
<p>To switch off this feature, use <code>--increase-x-height=0</code> (or check the ‘No x Height Increase’ box in the GUI). To switch off rounding the x height to the pixel grid in general, either partially or completely, see <a href="#x-height-snapping-exceptions">‘x Height Snapping Exceptions’</a>.</p>
<p>The following images again use the font ‘Mertz Bold’.</p>
<div class="figure">
<img src="img/e-17px-x14.png" alt="At 17px, without option -x and -w &quot;&quot;, the hole in glyph e looks very grey in the FontForge snapshot, and the GDI ClearType rendering (which is the default on older Windows versions) fills it completely with black because it uses B/W rendering along the y axis. FreeType’s light autohint mode (which corresponds to ttfautohint’s smooth stem width algorithm) intentionally aligns horizontal lines to non-integer (but still discrete) values to avoid large glyph shape distortions." /><p class="caption">At 17px, without option <code>-x</code> and ‘<code>-w &quot;&quot;</code>’, the hole in glyph ‘e’ looks very grey in the FontForge snapshot, and the GDI ClearType rendering (which is the default on older Windows versions) fills it completely with black because it uses B/W rendering along the y axis. FreeType’s ‘light’ autohint mode (which corresponds to ttfautohint’s ‘smooth’ stem width algorithm) intentionally aligns horizontal lines to non-integer (but still discrete) values to avoid large glyph shape distortions.</p>
</div>
<div class="figure">
<img src="img/e-17px-x17.png" alt="The same, this time with option -x 17 (and -w &quot;&quot;)." /><p class="caption">The same, this time with option <code>-x 17</code> (and ‘<code>-w &quot;&quot;</code>’).</p>
</div>
</dd>
</dl>
<h3 id="x-height-snapping-exceptions"><a href="#TOC">x Height Snapping Exceptions</a></h3>
<dl>
<dt><code>--x-height-snapping-exceptions=</code><em>string</em>, <code>-X</code> <em>string</em></dt>
<dd><p>A list of comma separated PPEM values or value ranges at which no x-height snapping shall be applied. A value range has the form <em>value1</em><code>-</code><em>value2</em>, meaning <em>value1</em> &lt;= PPEM &lt;= <em>value2</em>. <em>value1</em> or <em>value2</em> (or both) can be missing; a missing value is replaced by the beginning or end of the whole interval of valid PPEM values, respectively (6 to 32767). Whitespace is not significant; superfluous commas are ignored, and ranges must be specified in increasing order. For example, the string <code>&quot;7-9, 11, 13-&quot;</code> means the values 7, 8, 9, 11, 13, 14, 15, etc. Consequently, if the supplied argument is <code>&quot;-&quot;</code>, no x-height snapping takes place at all. The default is the empty string (<code>&quot;&quot;</code>), meaning no snapping exceptions.</p>
<p>Normally, x-height snapping means a slight increase in the overall vertical glyph size so that the height of lowercase glyphs gets aligned to the pixel grid (this is a global feature, affecting <em>all</em> glyphs of a font). However, having larger vertical glyph sizes is not always desired, especially if it is not possible to adjust the <code>usWinAscent</code> and <code>usWinDescent</code> values from the font’s <code>OS/2</code> table so that they are not too tight. See <a href="#windows-compatibility">‘Windows Compatibility’</a> for more details.</p>
</dd>
</dl>
<h3 id="windows-compatibility"><a href="#TOC">Windows Compatibility</a></h3>
<dl>
<dt><code>--windows-compatibility</code>, <code>-W</code></dt>
<dd><p>This option makes ttfautohint add two artificial blue zones, positioned at the <code>usWinAscent</code> and <code>usWinDescent</code> values (from the font’s <code>OS/2</code> table). The idea is to help ttfautohint so that the hinted glyphs stay within this horizontal stripe since Windows clips everything falling outside.</p>
<p>There is a general problem with tight values for <code>usWinAscent</code> and <code>usWinDescent</code>; a good description is given in the <a href="http://typophile.com/node/13081">Vertical Metrics How-To</a>. Additionally, there is a special problem with tight values if used in combination with ttfautohint because the auto-hinter tends to slightly increase the vertical glyph dimensions at smaller sizes to improve legibility. This enlargement can make the heights and depths of glyphs exceed the range given by <code>usWinAscent</code> and <code>usWinDescent</code>.</p>
<p>If ttfautohint is part of the font creation tool chain, and the font designer can adjust those two values, a better solution instead of using option <code>-W</code> is to reserve some vertical space for ‘padding’: For the auto-hinter, the difference between a top or bottom outline point before and after hinting is less than 1px, thus a vertical padding of 2px is sufficient. Assuming a minimum hinting size of 6ppem, adding two pixels gives an increase factor of 8÷6 = 1.33. This is near to the default baseline-to-baseline distance used by TeX and other sophisticated text processing applications, namely 1.2×designsize, which gives satisfying results in most cases. It is also near to the factor 1.25 recommended in the abovementioned How-To. For example, if the vertical extension of the largest glyph is 2000 units (assuming that it approximately represents the designsize), the sum of <code>usWinAscent</code> and <code>usWinDescent</code> could be 1.25×2000 = 2500.</p>
<p>In case ttfautohint is used as an auto-hinting tool for fonts which can be no longer modified to change the metrics, option <code>-W</code> in combination with ‘<code>-X &quot;-&quot;</code>’ to suppress any vertical enlargement should prevent almost all clipping.</p>
</dd>
</dl>
<h3 id="pre-hinting"><a href="#TOC">Pre-Hinting</a></h3>
<dl>
<dt><code>--pre-hinting</code>, <code>-p</code></dt>
<dd><em>Pre-hinting</em> means that a font’s original bytecode is applied to all glyphs before it is replaced with bytecode created by ttfautohint. This makes only sense if your font already has some hints in it which modify the shape even at EM size (normally 2048px); for example, some CJK fonts need this because the bytecode is used to scale and shift subglyphs. For most fonts, however, this is not the case.
</dd>
</dl>
<h3 id="hint-with-components"><a href="#TOC">Hint With Components</a></h3>
<dl>
<dt><code>--components</code>, <code>-c</code></dt>
<dd><p>Hint glyph components separately instead of hinting composite glyphs as a whole. Using this flag reduces the bytecode size enormously, however, it might yield worse results. In the GUI it is similar: If you uncheck the ‘Process With Components’ box, glyph components are hinted separately.</p>
<p>If a font contains composite glyphs and those glyphs are hinted as a whole, ttfautohint cannot reprocess its own output.</p>
</dd>
</dl>
<h3 id="symbol-font"><a href="#TOC">Symbol Font</a></h3>
<dl>
<dt><code>--symbol</code>, <code>-s</code></dt>
<dd>Use default values for standard (horizontal) stem width and height instead of deriving them from latin character ‘o’. Use this option (usually in combination with option <code>--latin-fallback</code>) to hint symbol or dingbat fonts or math glyphs, for example, which lack character ‘o’, at the expense of possibly poor hinting results at small sizes.
</dd>
</dl>
<h3 id="dehint"><a href="#TOC">Dehint</a></h3>
<dl>
<dt><code>--dehint</code>, <code>-d</code></dt>
<dd>Strip off all hints without generating new hints. Consequently, all other hinting options are ignored. This option is intended for testing purposes.
</dd>
</dl>
<h3 id="add-ttfautohint-info"><a href="#TOC">Add ttfautohint Info</a></h3>
<dl>
<dt><code>--no-info</code>, <code>-n</code></dt>
<dd>Don’t add ttfautohint version and command line information to the version string or strings (with name ID 5) in the font’s <code>name</code> table. In the GUI it is similar: If you uncheck the ‘Add ttfautohint info’ box, information is not added to the <code>name</code> table. Except for testing and development purposes it is strongly recommended to not use this option.
</dd>
</dl>
<h3 id="strong-stem-width-and-positioning"><a href="#TOC">Strong Stem Width and Positioning</a></h3>
<dl>
<dt><code>--strong-stem-width=</code><em>string</em>, <code>-w</code> <em>string</em></dt>
<dd><p>ttfautohint offers two different routines to handle (horizontal) stem widths and stem positions: ‘smooth’ and ‘strong’. The former uses discrete values which slightly increase the stem contrast with almost no distortion of the outlines, while the latter snaps both stem widths and stem positions to integer pixel values as much as possible, yielding a crisper appearance at the cost of much more distortion.</p>
<p>These two routines are mapped onto three possible rendering targets:</p>
<ul>
<li><p>grayscale rendering, with or without optimization for subpixel positioning (e.g. Mac OS X)</p></li>
<li><p>‘GDI ClearType’ rendering: the rasterizer version, as returned by the GETINFO bytecode instruction, is in the range 36 &lt;= version &lt; 38 and ClearType is enabled (e.g. Windows XP)</p></li>
<li><p>‘DirectWrite ClearType’ rendering: the rasterizer version, as returned by the GETINFO bytecode instruction, is &gt;= 38, ClearType is enabled, and subpixel positioning is enabled also (e.g. Internet Explorer 9 running on Windows 7)</p></li>
</ul>
<p>GDI ClearType uses a mode similar to B/W rendering along the vertical axis, while DW ClearType applies grayscale rendering. Additionally, only DW ClearType provides subpixel positioning along the x axis. For what it’s worth, the rasterizers version 36 and version 38 in Microsoft Windows are two completely different rendering engines.</p>
<p>The command line option expects <em>string</em> to contain up to three letters with possible values ‘<code>g</code>’ for grayscale, ‘<code>G</code>’ for GDI ClearType, and ‘<code>D</code>’ for DW ClearType. If a letter is found in <em>string</em>, the strong stem width routine is used for the corresponding rendering target. The default value is ‘<code>G</code>’ which means that strong stem width handling is activated for GDI ClearType only. To use smooth stem width handling for all three rendering targets, use the empty string as an argument, usually connoted with ‘<code>&quot;&quot;</code>’.</p>
<p>In the GUI, simply set the corresponding check box to select the stem width routine for a given rendering target.</p>
<p>The following FontForge snapshot images use the font <a href="http://code.newtypography.co.uk/mertz-sans/">‘Mertz Bold’</a> (still under development) from <a href="http://code.newtypography.co.uk">Vernon Adams</a>.</p>
<div class="figure">
<img src="img/ff-g-26px.png" alt="The left part shows the glyph g unhinted at 26px, the right part with hints, using the smooth stem algorithm." /><p class="caption">The left part shows the glyph ‘g’ unhinted at 26px, the right part with hints, using the ‘smooth’ stem algorithm.</p>
</div>
<div class="figure">
<img src="img/ff-g-26px-wD.png" alt="The same, but this time using the strong algorithm. Note how the stems are aligned to the pixel grid." /><p class="caption">The same, but this time using the ‘strong’ algorithm. Note how the stems are aligned to the pixel grid.</p>
</div>
</dd>
</dl>
<h3 id="font-license-restrictions"><a href="#TOC">Font License Restrictions</a></h3>
<dl>
<dt><code>--ignore-restrictions</code>, <code>-i</code></dt>
<dd><p>By default, fonts which have bit 1 set in the ‘fsType’ field of the <code>OS/2</code> table are rejected. If you have a permission of the font’s legal owner to modify the font, specify this command line option.</p>
<p>If this option is not set, <code>ttfautohintGUI</code> shows a dialogue to handle such fonts if necessary.</p>
</dd>
</dl>
<h3 id="miscellaneous"><a href="#TOC">Miscellaneous</a></h3>
<dl>
<dt><code>--help</code>, <code>-h</code></dt>
<dd><p>On the console, print a brief documentation on standard output and exit. This doesn’t work with <code>ttfautohintGUI</code> on MS Windows.</p>
</dd>
<dt><code>--version</code>, <code>-v</code></dt>
<dd><p>On the console, print version information on standard output and exit. This doesn’t work with <code>ttfautohintGUI</code> on MS Windows.</p>
</dd>
<dt><code>--debug</code></dt>
<dd><p>Print <em>a lot</em> of debugging information on standard error while processing a font (you should redirect stderr to a file). This doesn’t work with <code>ttfautohintGUI</code> on MS Windows.</p>
</dd>
</dl>
<h1 id="background-and-technical-details"><a href="#TOC">Background and Technical Details</a></h1>
<p><a href="http://www.tug.org/TUGboat/tb24-3/lemberg.pdf">Real-Time Grid Fitting of Typographic Outlines</a> is a scholarly paper which describes FreeType’s auto-hinter in some detail. Regarding the described data structures it is slightly out of date, but the algorithm itself hasn’t changed.</p>
<p>The next few subsections are mainly based on this article, introducing some important concepts. Note that ttfautohint only does hinting along the vertical direction (this is, modifying y coordinates).</p>
<h2 id="segments-and-edges"><a href="#TOC">Segments and Edges</a></h2>
<p>A glyph consists of one or more <em>contours</em> (this is, closed curves). For example, glyph ‘O’ consists of two contours, while glyph ‘I’ has only one.</p>
<div class="figure">
<img src="img/o-and-i.svg" alt="The letter O has two contours, an inner and an outer one, while letter I has only an outer contour." /><p class="caption">The letter ‘O’ has two contours, an inner and an outer one, while letter ‘I’ has only an outer contour.</p>
</div>
<p>A <em>segment</em> is a series of consecutive points of a contour (including its Bézier control points) that are approximately aligned along a coordinate axis.</p>
<div class="figure">
<img src="img/segment-edge.svg" alt="A serif. Contour and control points are represented by squares and circles, respectively. The bottom line DE is approximately aligned along the horizontal axis, thus it forms a segment of 7 points. Together with the two other horizontal segments, BC and FG, they form two edges (BC+FG, DE)." /><p class="caption">A serif. Contour and control points are represented by squares and circles, respectively. The bottom ‘line’ DE is approximately aligned along the horizontal axis, thus it forms a segment of 7 points. Together with the two other horizontal segments, BC and FG, they form two edges (BC+FG, DE).</p>
</div>
<p>An <em>edge</em> corresponds to a single coordinate value on the main dimension that collects one or more segments (allowing for a small threshold). While finding segments is done on the unscaled outline, finding edges is bound to the device resolution. See <a href="#hint-sets">below</a> for an example.</p>
<p>The analysis to find segments and edges is specific to a script.</p>
<h2 id="feature-analysis"><a href="#TOC">Feature Analysis</a></h2>
<p>The auto-hinter analyzes a font in two steps. Right now, everything described below happens for the horizontal axis only, providing vertical hinting.</p>
<ul>
<li><p>Global Analysis</p>
<p>This affects the hinting of all glyphs, trying to give them a uniform appearance.</p>
<ul>
<li><p>Compute standard stem widths and heights of the font. The values are normally taken from the glyph of letter ‘o’.</p></li>
<li><p>Compute blue zones, see <a href="#blue-zones">below</a>.</p></li>
</ul>
<p>If stem widths and heights of single glyphs differ by a large value, or if ttfautohint fails to find proper blue zones, hinting becomes quite poor, leading even to severe shape distortions.</p></li>
<li><p>Glyph Analysis</p>
<p>This is a per-glyph operation.</p>
<ul>
<li><p>Find segments and edges.</p></li>
<li><p>Link edges together to find stems and serifs. The abovementioned paper gives more details on what exactly constitutes a stem or a serif and how the algorithm works.</p></li>
</ul></li>
</ul>
<h2 id="blue-zones"><a href="#TOC">Blue Zones</a></h2>
<div class="figure">
<img src="img/blue-zones.svg" alt="Two blue zones relevant to the glyph a. Vertical point coordinates of all glyphs within these zones are aligned." /><p class="caption">Two blue zones relevant to the glyph ‘a’. Vertical point coordinates of <em>all</em> glyphs within these zones are aligned.</p>
</div>
<p>Outlines of certain characters are used to determine <em>blue zones</em>. This concept is the same as with Type 1 fonts: All glyph points which lie in certain small horizontal zones get aligned vertically.</p>
<p>Here a table which shows the characters used by the latin module; the values are hard-coded in the source code.</p>
<table>
<thead>
<tr class="header">
<th align="left">ID</th>
<th align="left">Blue zone</th>
<th align="left">Characters</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">top of capital letters</td>
<td align="left">THEZOCQS</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">bottom of capital letters</td>
<td align="left">HEZLOCUS</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">top of ‘small f’ like letters</td>
<td align="left">fijkdbh</td>
</tr>
<tr class="even">
<td align="left">4</td>
<td align="left">top of small letters</td>
<td align="left">xzroesc</td>
</tr>
<tr class="odd">
<td align="left">5</td>
<td align="left">bottom of small letters</td>
<td align="left">xzroesc</td>
</tr>
<tr class="even">
<td align="left">6</td>
<td align="left">bottom of descenders of small letters</td>
<td align="left">pqgjy</td>
</tr>
</tbody>
</table>
<p>The ‘round’ characters (e.g. ‘OCQS’) from Zones 1, 2, and 5 are also used to control the overshoot handling; to improve rendering at small sizes, zone 4 gets adjusted to be on the pixel grid; cf. the <a href="#x-height-increase-limit"><code>--increase-x-height</code> option</a>.</p>
<div class="figure">
<img src="img/glyph-terms.svg" alt="This image shows the relevant glyph terms for vertical blue zone positions." /><p class="caption">This image shows the relevant glyph terms for vertical blue zone positions.</p>
</div>
<h2 id="grid-fitting"><a href="#TOC">Grid Fitting</a></h2>
<p>Aligning outlines along the grid lines is called <em>grid fitting</em>. It doesn’t necessarily mean that the outlines are positioned <em>exactly</em> on the grid, however, especially if you want a smooth appearance at different sizes. This is the central routine of the auto-hinter; its actions are highly dependent on the used script. Currently, only support for scripts which work similarly to Latin (i.e. Greek and Cyrillic) is available.</p>
<ul>
<li><p>Align edges linked to blue zones.</p></li>
<li><p>Fit edges to the pixel grid.</p></li>
<li><p>Align serif edges.</p></li>
<li><p>Handle remaining ‘strong’ points. Such points are not part of an edge but are still important for defining the shape. This roughly corresponds to the <code>IP</code> TrueType instruction.</p></li>
<li><p>Everything else (the ‘weak’ points) is handled with an <code>IUP</code> instruction.</p></li>
</ul>
<p>The following images illustrate the hinting process, using glyph ‘a’ from the freely available font <a href="http://font.ubuntu.com">‘Ubuntu Book’</a>. The manual hints were added by <a href="http://daltonmaag.com">Dalton Maag Ltd</a>, the used application to create the hinting debug snapshots was <a href="http://fontforge.sf.net">FontForge</a>.</p>
<div class="figure">
<img src="img/a-before-hinting.png" alt="Before hinting." /><p class="caption">Before hinting.</p>
</div>
<div class="figure">
<img src="img/a-after-hinting.png" alt="After hinting, using manual hints." /><p class="caption">After hinting, using manual hints.</p>
</div>
<div class="figure">
<img src="img/a-after-autohinting.png" alt="After hinting, using ttfautohint. Note that the hinting process doesn’t change horizontal positions." /><p class="caption">After hinting, using ttfautohint. Note that the hinting process doesn’t change horizontal positions.</p>
</div>
<h2 id="hint-sets"><a href="#TOC">Hint Sets</a></h2>
<p>In ttfautohint terminology, a <em>hint set</em> is the <em>optimal</em> configuration for a given PPEM (pixel per EM) value.</p>
<p>In the range given by the <code>--hinting-range-min</code> and <code>--hinting-range-max</code> options, ttfautohint creates hint sets for every PPEM value. For each glyph, ttfautohint automatically determines if a new set should be emitted for a PPEM value if it finds that it differs from a previous one. For some glyphs it is possible that one set covers, say, the range 8px-1000px, while other glyphs need 10 or more such sets.</p>
<p>In the PPEM range below <code>--hinting-range-min</code>, ttfautohint always uses just one set, in the PPEM range between <code>--hinting-range-max</code> and <code>--hinting-limit</code>, it also uses just one set.</p>
<p>One of the hinting configuration parameters is the decision which segments form an edge. For example, let us assume that two segments get aligned on a single horizontal edge at 11px, while two edges are used at 12px. This change makes ttfautohint emit a new hint set to accomodate this situation.</p>
<p>The next images illustrate this, using a Cyrillic letter (glyph ‘afii10108’) from the ‘Ubuntu book’ font, processed with ttfautohint.</p>
<div class="figure">
<img src="img/afii10108-11px-before-hinting.png" alt="Before hinting, size 11px." /><p class="caption">Before hinting, size 11px.</p>
</div>
<div class="figure">
<img src="img/afii10108-11px-after-hinting.png" alt="After hinting, size 11px. Segments 43-27-28 and 14-15 are aligned on a single edge, as are segments 26-0-1 and 20-21." /><p class="caption">After hinting, size 11px. Segments 43-27-28 and 14-15 are aligned on a single edge, as are segments 26-0-1 and 20-21.</p>
</div>
<div class="figure">
<img src="img/afii10108-12px-before-hinting.png" alt="Before hinting, size 12px." /><p class="caption">Before hinting, size 12px.</p>
</div>
<div class="figure">
<img src="img/afii10108-12px-after-hinting.png" alt="After hinting, size 12px. The segments are not aligned. While segments 43-27-28 and 20-21 now have almost the same horizontal position, they don’t form an edge because the outlines passing through the segments point into different directions." /><p class="caption">After hinting, size 12px. The segments are not aligned. While segments 43-27-28 and 20-21 now have almost the same horizontal position, they don’t form an edge because the outlines passing through the segments point into different directions.</p>
</div>
<p>Obviously, the more hint sets get emitted, the larger the bytecode ttfautohint adds to the output font. To find a good value <em>n</em> for <code>--hinting-range-max</code>, some experimentation is necessary since <em>n</em> depends on the glyph shapes in the input font. If the value is too low, the hint set created for the PPEM value <em>n</em> (this hint set gets used for all larger PPEM values) might distort the outlines too much in the PPEM range given by <em>n</em> and the value set by <code>--hinting-limit</code> (at which hinting gets switched off). If the value is too high, the font size increases due to more hint sets without any noticeable hinting effects.</p>
<p>Similar arguments hold for <code>--hinting-range-min</code> except that there is no lower limit at which hinting is switched off.</p>
<p>An example. Let’s assume that we have a hinting range 10 &lt;= ppem &lt;= 100, and the hinting limit is set to 250. For a given glyph, ttfautohint finds out that four hint sets must be computed to exactly cover thes hinting range: 10-15, 16-40, 41-80, and 81-100. For ppem values below 10ppem, the hint set covering 10-15ppem is used, for ppem values larger than 100 the hint set covering 81-100ppem is used. For ppem values larger than 250, no hinting gets applied.</p>
<h2 id="the-.ttfautohint-glyph"><a href="#TOC">The ‘.ttfautohint’ Glyph</a></h2>
<p>[The behaviour described in this section does not apply if <a href="#hint-with-components">option <code>--components</code></a> is used.]</p>
<p>By default, ttfautohint doesn’t hint subglyphs of composite glyphs separately. Instead, it hints the whole glyph, this is, composites get recursively expanded internally so that they form simple glyphs, then hints are applied – this is the normal working mode of FreeType’s auto-hinter.</p>
<p>One problem, however, must be solved: Hinting for subglyphs (which usually are used as normal glyphs also) must be deactivated so that nothing but the final bytecode of the composite gets executed.</p>
<p>The trick used by ttfautohint is to prepend a composite element called ‘.ttfautohint’, a dummy glyph with a single point, and which has a single job: Its bytecode increases a variable (to be more precise, it is a CVT register called <code>cvtl_is_subglyph</code> in the source code), indicating that we are within a composite glyph. The final bytecode of the composite glyph eventually decrements this variable again.</p>
<p>As an example, let’s consider composite glyph ‘Agrave’ (‘À’) which has the subglyph ‘A’ as the base and ‘grave’ as its accent. After processing with ttfautohint it consists of three subglyphs: ‘.ttfautohint’, ‘A’, and ‘grave’ (in this order).</p>
<table>
<thead>
<tr class="header">
<th align="left">Bytecode of</th>
<th align="left">Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">.ttfautohint</td>
<td align="left">increase <code>cvtl_is_subglyph</code> (now: 1)</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">do nothing because <code>cvtl_is_subglyph</code> &gt; 0</td>
</tr>
<tr class="odd">
<td align="left">grave</td>
<td align="left">do nothing because <code>cvtl_is_subglyph</code> &gt; 0</td>
</tr>
<tr class="even">
<td align="left">Agrave</td>
<td align="left">decrease <code>cvtl_is_subglyph</code> (now: 0)</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">apply hints because <code>cvtl_is_subglyph</code> == 0</td>
</tr>
</tbody>
</table>
<p>Some technical details (which you might skip): All glyph point indices get adjusted since each ‘.ttfautohint’ subglyph shifts all following indices by one. This must be done for both the bytecode and one subformat of OpenType’s <code>GPOS</code> anchor tables.</p>
<p>While this approach works fine on all tested platforms, there is one single drawback: Direct rendering of the ‘.ttfautohint’ subglyph (this is, rendering as a stand-alone glyph) disables proper hinting of all glyphs in the font! Under normal circumstances this never happens because ‘.ttfautohint’ doesn’t have an entry in the font’s <code>cmap</code> table. (However, some test and demo programs like FreeType’s <code>ftview</code> application or other glyph viewers which are able to bypass the <code>cmap</code> table might be affected.)</p>
<h2 id="scripts"><a href="#TOC">Scripts</a></h2>
<p>ttfautohint checks which auto-hinting module should be used to hint a specific glyph. To do so, it checks a glyph’s Unicode character code whether it belongs to a given script. Currently, only FreeType’s ‘latin’ autohinting module is implemented, but more are expected to come. Here is the hardcoded list of character ranges which are hinted by this ‘latin’ module. As you can see, this also covers some non-latin scripts (in the Unicode sense) which have similar typographical properties.</p>
<table>
<thead>
<tr class="header">
<th align="center">Character range</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><code>0x0020</code> - <code>0x007F</code></td>
<td align="left">Basic Latin (no control characters)</td>
</tr>
<tr class="even">
<td align="center"><code>0x00A0</code> - <code>0x00FF</code></td>
<td align="left">Latin-1 Supplement (no control characters)</td>
</tr>
<tr class="odd">
<td align="center"><code>0x0100</code> - <code>0x017F</code></td>
<td align="left">Latin Extended-A</td>
</tr>
<tr class="even">
<td align="center"><code>0x0180</code> - <code>0x024F</code></td>
<td align="left">Latin Extended-B</td>
</tr>
<tr class="odd">
<td align="center"><code>0x0250</code> - <code>0x02AF</code></td>
<td align="left">IPA Extensions</td>
</tr>
<tr class="even">
<td align="center"><code>0x02B0</code> - <code>0x02FF</code></td>
<td align="left">Spacing Modifier Letters</td>
</tr>
<tr class="odd">
<td align="center"><code>0x0300</code> - <code>0x036F</code></td>
<td align="left">Combining Diacritical Marks</td>
</tr>
<tr class="even">
<td align="center"><code>0x0370</code> - <code>0x03FF</code></td>
<td align="left">Greek and Coptic</td>
</tr>
<tr class="odd">
<td align="center"><code>0x0400</code> - <code>0x04FF</code></td>
<td align="left">Cyrillic</td>
</tr>
<tr class="even">
<td align="center"><code>0x0500</code> - <code>0x052F</code></td>
<td align="left">Cyrillic Supplement</td>
</tr>
<tr class="odd">
<td align="center"><code>0x1D00</code> - <code>0x1D7F</code></td>
<td align="left">Phonetic Extensions</td>
</tr>
<tr class="even">
<td align="center"><code>0x1D80</code> - <code>0x1DBF</code></td>
<td align="left">Phonetic Extensions Supplement</td>
</tr>
<tr class="odd">
<td align="center"><code>0x1DC0</code> - <code>0x1DFF</code></td>
<td align="left">Combining Diacritical Marks Supplement</td>
</tr>
<tr class="even">
<td align="center"><code>0x1E00</code> - <code>0x1EFF</code></td>
<td align="left">Latin Extended Additional</td>
</tr>
<tr class="odd">
<td align="center"><code>0x1F00</code> - <code>0x1FFF</code></td>
<td align="left">Greek Extended</td>
</tr>
<tr class="even">
<td align="center"><code>0x2000</code> - <code>0x206F</code></td>
<td align="left">General Punctuation</td>
</tr>
<tr class="odd">
<td align="center"><code>0x2070</code> - <code>0x209F</code></td>
<td align="left">Superscripts and Subscripts</td>
</tr>
<tr class="even">
<td align="center"><code>0x20A0</code> - <code>0x20CF</code></td>
<td align="left">Currency Symbols</td>
</tr>
<tr class="odd">
<td align="center"><code>0x2150</code> - <code>0x218F</code></td>
<td align="left">Number Forms</td>
</tr>
<tr class="even">
<td align="center"><code>0x2460</code> - <code>0x24FF</code></td>
<td align="left">Enclosed Alphanumerics</td>
</tr>
<tr class="odd">
<td align="center"><code>0x2C60</code> - <code>0x2C7F</code></td>
<td align="left">Latin Extended-C</td>
</tr>
<tr class="even">
<td align="center"><code>0x2DE0</code> - <code>0x2DFF</code></td>
<td align="left">Cyrillic Extended-A</td>
</tr>
<tr class="odd">
<td align="center"><code>0x2E00</code> - <code>0x2E7F</code></td>
<td align="left">Supplemental Punctuation</td>
</tr>
<tr class="even">
<td align="center"><code>0xA640</code> - <code>0xA69F</code></td>
<td align="left">Cyrillic Extended-B</td>
</tr>
<tr class="odd">
<td align="center"><code>0xA720</code> - <code>0xA7FF</code></td>
<td align="left">Latin Extended-D</td>
</tr>
<tr class="even">
<td align="center"><code>0xFB00</code> - <code>0xFB06</code></td>
<td align="left">Alphabetical Presentation Forms (Latin Ligatures)</td>
</tr>
<tr class="odd">
<td align="center"><code>0x1D400</code> - <code>0x1D7FF</code></td>
<td align="left">Mathematical Alphanumeric Symbols</td>
</tr>
<tr class="even">
<td align="center"><code>0x1F100</code> - <code>0x1F1FF</code></td>
<td align="left">Enclosed Alphanumeric Supplement</td>
</tr>
</tbody>
</table>
<p>If a glyph’s character code is not covered by a script range, it is not hinted (or rather, it gets hinted by the ‘dummy’ auto-hinting module which essentially does nothing). This can be changed by specifying a <em>fallback script</em> with <a href="#fallback-script">option <code>--latin-fallback</code></a>.</p>
<p>It is planned to extend ttfautohint so that the <code>GSUB</code> OpenType table gets analyzed, mapping character codes to all glyph indices which can be reached by switching on or off various OpenType features.</p>
<h2 id="sfnt-tables"><a href="#TOC">SFNT Tables</a></h2>
<p>ttfautohint touches almost all SFNT tables within a TrueType or OpenType font. Note that only OpenType fonts with TrueType outlines are supported. OpenType fonts with a <code>CFF</code> table (this is, with PostScript outlines) won’t work.</p>
<ul>
<li><p><code>glyf</code>: One glyph gets added (namely the ‘.ttfautohint’ glyph); all composites get an additional component; all hints in the table are replaced with new ones.</p></li>
<li><p><code>cvt</code>, <code>prep</code>, and <code>fpgm</code>: These tables get replaced with data necessary for the new hinting bytecode.</p></li>
<li><p><code>gasp</code>: Set up to always use grayscale rendering with grid-fitting for standard hinting, and symmetric grid-fitting and symmetric smoothing for horizontal subpixel hinting (ClearType).</p></li>
<li><p><code>DSIG</code>: If it exists, it gets replaced with a dummy version. ttfautohint can’t digitally sign a font; you have to do that afterwards.</p></li>
<li><p><code>name</code>: The ‘version’ entries are modified to add information about the parameters which have been used for calling ttfautohint. This can be controlled with the <a href="#add-ttfautohint-info"><code>--no-info</code></a> option.</p></li>
<li><p><code>GPOS</code>, <code>hmtx</code>, <code>loca</code>, <code>head</code>, <code>maxp</code>, <code>post</code>: Updated to fit the additional ‘.ttfautohint’ glyph, the additional subglyphs in composites, and the new hinting bytecode.</p></li>
<li><p><code>LTSH</code>, <code>hdmx</code>: Since ttfautohint doesn’t do any horizontal hinting, those tables are superfluous and thus removed.</p></li>
<li><p><code>VDMX</code>: Removed, since it depends on the original bytecode which ttfautohint removes. A font editor might recompute the necessary data later on.</p></li>
</ul>
<h2 id="problems"><a href="#TOC">Problems</a></h2>
<p>Diagonals.</p>
<p>TODO</p>
<h1 id="the-ttfautohint-api"><a href="#TOC">The ttfautohint API</a></h1>
<p>This section documents the single function of the ttfautohint library, <code>TTF_autohint</code>, together with its callback functions, <code>TA_Progress_Func</code> and <code>TA_Info_Func</code>. All information has been directly extracted from the <code>ttfautohint.h</code> header file.</p>
<h2 id="preprocessor-macros-and-typedefs"><a href="#TOC">Preprocessor Macros and Typedefs</a></h2>
<p>Some default values.</p>
<pre class="sourceCode C"><code class="sourceCode c"><span class="ot">#define TA_HINTING_RANGE_MIN 8</span>
<span class="ot">#define TA_HINTING_RANGE_MAX 50</span>
<span class="ot">#define TA_HINTING_LIMIT 200</span>
<span class="ot">#define TA_INCREASE_X_HEIGHT 14</span></code></pre>
<p>An error type.</p>
<pre class="sourceCode C"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">int</span> TA_Error;</code></pre>
<h2 id="callback-ta_progress_func"><a href="#TOC">Callback: <code>TA_Progress_Func</code></a></h2>
<p>A callback function to get progress information. <em>curr_idx</em> gives the currently processed glyph index; if it is negative, an error has occurred. <em>num_glyphs</em> holds the total number of glyphs in the font (this value can’t be larger than 65535).</p>
<p><em>curr_sfnt</em> gives the current subfont within a TrueType Collection (TTC), and <em>num_sfnts</em> the total number of subfonts.</p>
<p>If the return value is non-zero, <code>TTF_autohint</code> aborts with <code>TA_Err_Canceled</code>. Use this for a ‘Cancel’ button or similar features in interactive use.</p>
<p><em>progress_data</em> is a void pointer to user supplied data.</p>
<pre class="sourceCode C"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">int</span>
(*TA_Progress_Func)(<span class="dt">long</span> curr_idx,
                    <span class="dt">long</span> num_glyphs,
                    <span class="dt">long</span> curr_sfnt,
                    <span class="dt">long</span> num_sfnts,
                    <span class="dt">void</span>* progress_data);</code></pre>
<h2 id="callback-ta_info_func"><a href="#TOC">Callback: <code>TA_Info_Func</code></a></h2>
<p>A callback function to manipulate strings in the <code>name</code> table. <em>platform_id</em>, <em>encoding_id</em>, <em>language_id</em>, and <em>name_id</em> are the identifiers of a <code>name</code> table entry pointed to by <em>str</em> with a length pointed to by <em>str_len</em> (in bytes; the string has no trailing NULL byte). Please refer to the <a href="http://www.microsoft.com/typography/otspec/name.htm">OpenType specification</a> for a detailed description of the various parameters, in particular which encoding is used for a given platform and encoding ID.</p>
<p>The string <em>str</em> is allocated with <code>malloc</code>; the application should reallocate the data if necessary, ensuring that the string length doesn’t exceed 0xFFFF.</p>
<p><em>info_data</em> is a void pointer to user supplied data.</p>
<p>If an error occurs, return a non-zero value and don’t modify <em>str</em> and <em>str_len</em> (such errors are handled as non-fatal).</p>
<pre class="sourceCode C"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">int</span>
(*TA_Info_Func)(<span class="dt">unsigned</span> <span class="dt">short</span> platform_id,
                <span class="dt">unsigned</span> <span class="dt">short</span> encoding_id,
                <span class="dt">unsigned</span> <span class="dt">short</span> language_id,
                <span class="dt">unsigned</span> <span class="dt">short</span> name_id,
                <span class="dt">unsigned</span> <span class="dt">short</span>* str_len,
                <span class="dt">unsigned</span> <span class="dt">char</span>** str,
                <span class="dt">void</span>* info_data);</code></pre>
<h2 id="function-ttf_autohint"><a href="#TOC">Function: <code>TTF_autohint</code></a></h2>
<p>Read a TrueType font, remove existing bytecode (in the SFNT tables <code>prep</code>, <code>fpgm</code>, <code>cvt</code>, and <code>glyf</code>), and write a new TrueType font with new bytecode based on the autohinting of the FreeType library.</p>
<p>It expects a format string <em>options</em> and a variable number of arguments, depending on the fields in <em>options</em>. The fields are comma separated; whitespace within the format string is not significant, a trailing comma is ignored. Fields are parsed from left to right; if a field occurs multiple times, the last field’s argument wins. The same is true for fields which are mutually exclusive. Depending on the field, zero or one argument is expected.</p>
<p>Note that fields marked as ‘not implemented yet’ are subject to change.</p>
<h3 id="io"><a href="#TOC">I/O</a></h3>
<dl>
<dt><code>in-file</code></dt>
<dd><p>A pointer of type <code>FILE*</code> to the data stream of the input font, opened for binary reading. Mutually exclusive with <code>in-buffer</code>.</p>
</dd>
<dt><code>in-buffer</code></dt>
<dd><p>A pointer of type <code>const char*</code> to a buffer which contains the input font. Needs <code>in-buffer-len</code>. Mutually exclusive with <code>in-file</code>.</p>
</dd>
<dt><code>in-buffer-len</code></dt>
<dd><p>A value of type <code>size_t</code>, giving the length of the input buffer. Needs <code>in-buffer</code>.</p>
</dd>
<dt><code>out-file</code></dt>
<dd><p>A pointer of type <code>FILE*</code> to the data stream of the output font, opened for binary writing. Mutually exclusive with <code>out-buffer</code>.</p>
</dd>
<dt><code>out-buffer</code></dt>
<dd><p>A pointer of type <code>char**</code> to a buffer which contains the output font. Needs <code>out-buffer-len</code>. Mutually exclusive with <code>out-file</code>. Deallocate the memory with <code>free</code>.</p>
</dd>
<dt><code>out-buffer-len</code></dt>
<dd><p>A pointer of type <code>size_t*</code> to a value giving the length of the output buffer. Needs <code>out-buffer</code>.</p>
</dd>
</dl>
<h3 id="messages-and-callbacks"><a href="#TOC">Messages and Callbacks</a></h3>
<dl>
<dt><code>progress-callback</code></dt>
<dd><p>A pointer of type <a href="#callback-ta_progress_func"><code>TA_Progress_Func</code></a>, specifying a callback function for progress reports. This function gets called after a single glyph has been processed. If this field is not set or set to NULL, no progress callback function is used.</p>
</dd>
<dt><code>progress-callback-data</code></dt>
<dd><p>A pointer of type <code>void*</code> to user data which is passed to the progress callback function.</p>
</dd>
<dt><code>error-string</code></dt>
<dd><p>A pointer of type <code>unsigned char**</code> to a string (in UTF-8 encoding) which verbally describes the error code. You must not change the returned value.</p>
</dd>
<dt><code>info-callback</code></dt>
<dd><p>A pointer of type <a href="#callback-ta_info_func"><code>TA_Info_Func</code></a>, specifying a callback function for manipulating the <code>name</code> table. This function gets called for each <code>name</code> table entry. If not set or set to NULL, the table data stays unmodified.</p>
</dd>
<dt><code>info-callback-data</code></dt>
<dd><p>A pointer of type <code>void*</code> to user data which is passed to the info callback function.</p>
</dd>
<dt><code>debug</code></dt>
<dd><p>If this integer is set to 1, lots of debugging information is print to stderr. The default value is 0.</p>
</dd>
</dl>
<h3 id="general-hinting-options"><a href="#TOC">General Hinting Options</a></h3>
<dl>
<dt><code>hinting-range-min</code></dt>
<dd><p>An integer (which must be larger than or equal to 2) giving the lowest PPEM value used for autohinting. If this field is not set, it defaults to <code>TA_HINTING_RANGE_MIN</code>.</p>
</dd>
<dt><code>hinting-range-max</code></dt>
<dd><p>An integer (which must be larger than or equal to the value of <code>hinting-range-min</code>) giving the highest PPEM value used for autohinting. If this field is not set, it defaults to <code>TA_HINTING_RANGE_MAX</code>.</p>
</dd>
<dt><code>hinting-limit</code></dt>
<dd><p>An integer (which must be larger than or equal to the value of <code>hinting-range-max</code>) which gives the largest PPEM value at which hinting is applied. For larger values, hinting is switched off. If this field is not set, it defaults to <code>TA_HINTING_LIMIT</code>. If it is set to 0, no hinting limit is added to the bytecode.</p>
</dd>
<dt><code>hint-with-components</code></dt>
<dd><p>If this integer is set to 1 (which is the default), ttfautohint handles composite glyphs as a whole. This implies adding a special glyph to the font, as documented <a href="#the-.ttfautohint-glyph">here</a>. Setting it to 0, the components of composite glyphs are hinted separately. While separate hinting of subglyphs makes the resulting bytecode much smaller, it might deliver worse results. However, this depends on the processed font and must be checked by inspection.</p>
</dd>
<dt><code>pre-hinting</code></dt>
<dd><p>An integer (1 for ‘on’ and 0 for ‘off’, which is the default) to specify whether native TrueType hinting shall be applied to all glyphs before passing them to the (internal) autohinter. The used resolution is the em-size in font units; for most fonts this is 2048ppem. Use this if the hints move or scale subglyphs independently of the output resolution.</p>
</dd>
</dl>
<h3 id="hinting-algorithms"><a href="#TOC">Hinting Algorithms</a></h3>
<dl>
<dt><code>gray-strong-stem-width</code></dt>
<dd><p>An integer (1 for ‘on’ and 0 for ‘off’, which is the default) which specifies whether horizontal stems should be snapped and positioned to integer pixel values for normal grayscale rendering.</p>
</dd>
<dt><code>gdi-cleartype-strong-stem-width</code></dt>
<dd><p>An integer (1 for ‘on’, which is the default, and 0 for ‘off’) which specifies whether horizontal stems should be snapped and positioned to integer pixel values for GDI ClearType rendering, this is, the rasterizer version (as returned by the GETINFO bytecode instruction) is in the range 36 &lt;= version &lt; 38 and ClearType is enabled.</p>
</dd>
<dt><code>dw-cleartype-strong-stem-width</code></dt>
<dd><p>An integer (1 for ‘on’ and 0 for ‘off’, which is the default) which specifies whether horizontal stems should be snapped and positioned to integer pixel values for DW ClearType rendering, this is, the rasterizer version (as returned by the GETINFO bytecode instruction) is &gt;= 38, ClearType is enabled, and subpixel positioning is enabled also.</p>
</dd>
<dt><code>increase-x-height</code></dt>
<dd><p>An integer. For PPEM values in the range 6 &lt;= PPEM &lt;= <code>increase-x-height</code>, round up the font’s x height much more often than normally. If it is set to 0, this feature is switched off. If this field is not set, it defaults to <code>TA_INCREASE_X_HEIGHT</code>. Use this flag to improve the legibility of small font sizes if necessary.</p>
</dd>
<dt><code>x-height-snapping-exceptions</code></dt>
<dd><p>A pointer of type <code>const char*</code> to a null-terminated string which gives a list of comma separated PPEM values or value ranges at which no x-height snapping shall be applied. A value range has the form <em>value1</em><code>-</code><em>value2</em>, meaning <em>value1</em> &lt;= PPEM &lt;= <em>value2</em>. <em>value1</em> or <em>value2</em> (or both) can be missing; a missing value is replaced by the beginning or end of the whole interval of valid PPEM values, respectively. Whitespace is not significant; superfluous commas are ignored, and ranges must be specified in increasing order. For example, the string <code>&quot;3, 5-7, 9-&quot;</code> means the values 3, 5, 6, 7, 9, 10, 11, 12, etc. Consequently, if the supplied argument is <code>&quot;-&quot;</code>, no x-height snapping takes place at all. The default is the empty string (<code>&quot;&quot;</code>), meaning no snapping exceptions.</p>
</dd>
<dt><code>windows-compatibility</code></dt>
<dd><p>If this integer is set to 1, two artificial blue zones are used, positioned at the <code>usWinAscent</code> and <code>usWinDescent</code> values (from the font’s <code>OS/2</code> table). The idea is to help ttfautohint so that the hinted glyphs stay within this horizontal stripe since Windows clips everything falling outside. The default is 0.</p>
</dd>
</dl>
<h3 id="scripts-1"><a href="#TOC">Scripts</a></h3>
<dl>
<dt><code>fallback-script</code></dt>
<dd><p>An integer which specifies the default script for glyphs not in the ‘latin’ range. If set to 1, the ‘latin’ script is used (other scripts are not supported yet). By default, no script is used (value 0; this disables autohinting for such glyphs).</p>
</dd>
<dt><code>symbol</code></dt>
<dd><p>Set this integer to 1 if you want to process a font which lacks the characters of a supported script, for example, a symbol font. ttfautohint then uses default values for the standard stem width and height instead of deriving these values from a script’s key character (for the latin script, it is character ‘o’). The default value is 0.</p>
</dd>
</dl>
<h3 id="miscellaneous-1"><a href="#TOC">Miscellaneous</a></h3>
<dl>
<dt><code>ignore-restrictions</code></dt>
<dd><p>If the font has set bit 1 in the ‘fsType’ field of the <code>OS/2</code> table, the ttfautohint library refuses to process the font since a permission to do that is required from the font’s legal owner. In case you have such a permission you might set the integer argument to value 1 to make ttfautohint handle the font. The default value is 0.</p>
</dd>
<dt><code>dehint</code></dt>
<dd><p>If set to 1, remove all hints from the font. All other hinting options are ignored.</p>
</dd>
</dl>
<h3 id="remarks"><a href="#TOC">Remarks</a></h3>
<ul>
<li><p>Obviously, it is necessary to have an input and an output data stream. All other options are optional.</p></li>
<li><p><code>hinting-range-min</code> and <code>hinting-range-max</code> specify the range for which the autohinter generates optimized hinting code. If a PPEM value is smaller than the value of <code>hinting-range-min</code>, hinting still takes place but the configuration created for <code>hinting-range-min</code> is used. The analogous action is taken for <code>hinting-range-max</code>, only limited by the value given with <code>hinting-limit</code>. The font’s <code>gasp</code> table is set up to always use grayscale rendering with grid-fitting for standard hinting, and symmetric grid-fitting and symmetric smoothing for horizontal subpixel hinting (ClearType).</p></li>
<li><p>ttfautohint can’t process a font a second time (well, it can, if the font doesn’t contain composite glyphs). Just think of ttfautohint as being a compiler, a tool which also can’t process its created output again.</p></li>
</ul>
<pre class="sourceCode C"><code class="sourceCode c">TA_Error
TTF_autohint(<span class="dt">const</span> <span class="dt">char</span>* options,
             ...);</code></pre>
<h1 id="compilation-and-installation"><a href="#TOC">Compilation and Installation</a></h1>
<p>Please read the files <a href="http://repo.or.cz/w/ttfautohint.git/blob_plain/HEAD:/INSTALL"><code>INSTALL</code></a> and <a href="http://repo.or.cz/w/ttfautohint.git/blob_plain/HEAD:/INSTALL.git"><code>INSTALL.git</code></a> (part of the source code bundle) for instructions how to compile the ttfautohint library together with its front-ends.</p>
<p>TODO</p>
<h2 id="unix-platforms"><a href="#TOC">Unix Platforms</a></h2>
<p>TODO</p>
<h2 id="ms-windows"><a href="#TOC">MS Windows</a></h2>
<p>TODO</p>
<h2 id="mac-os-x"><a href="#TOC">Mac OS X</a></h2>
<p>TODO</p>
<h1 id="authors"><a href="#TOC">Authors</a></h1>
<p>Copyright © 2011-2013 by <script type="text/javascript">
<!--
h='&#x67;&#110;&#x75;&#46;&#x6f;&#114;&#x67;';a='&#64;';n='&#x77;&#108;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'">'+'Werner Lemberg'+'<\/'+'a'+'>');
// -->
</script><noscript>&#x57;&#x65;&#114;&#110;&#x65;&#114;&#32;&#76;&#x65;&#x6d;&#98;&#x65;&#114;&#x67;&#32;&#40;&#x77;&#108;&#32;&#x61;&#116;&#32;&#x67;&#110;&#x75;&#32;&#100;&#x6f;&#116;&#32;&#x6f;&#114;&#x67;&#x29;</noscript>.<br />Copyright © 2011-2013 by <script type="text/javascript">
<!--
h='&#x75;&#110;&#100;&#x65;&#114;&#x73;&#116;&#x61;&#110;&#100;&#x69;&#110;&#x67;&#102;&#x6f;&#110;&#116;&#x73;&#46;&#x63;&#x6f;&#x6d;';a='&#64;';n='&#100;&#x61;&#118;&#x65;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'">'+'Dave Crossland'+'<\/'+'a'+'>');
// -->
</script><noscript>&#68;&#x61;&#118;&#x65;&#32;&#x43;&#114;&#x6f;&#x73;&#x73;&#108;&#x61;&#110;&#100;&#32;&#40;&#100;&#x61;&#118;&#x65;&#32;&#x61;&#116;&#32;&#x75;&#110;&#100;&#x65;&#114;&#x73;&#116;&#x61;&#110;&#100;&#x69;&#110;&#x67;&#102;&#x6f;&#110;&#116;&#x73;&#32;&#100;&#x6f;&#116;&#32;&#x63;&#x6f;&#x6d;&#x29;</noscript>.</p>
<p>This file is part of the ttfautohint library, and may only be used, modified, and distributed under the terms given in <a href="http://repo.or.cz/w/ttfautohint.git/blob_plain/HEAD:/COPYING"><code>COPYING</code></a>. By continuing to use, modify, or distribute this file you indicate that you have read <code>COPYING</code> and understand and accept it fully.</p>
<p>The file <code>COPYING</code> mentioned in the previous paragraph is distributed with the ttfautohint library.</p>
      </div>
    </div>

    <div class="col2">
    </div>
  </div>
</div>

<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#what-exactly-are-hints">What exactly are hints?</a></li>
<li><a href="#what-problems-can-arise-with-truetype-hinting">What problems can arise with TrueType hinting?</a></li>
<li><a href="#why-ttfautohint">Why ttfautohint?</a></li>
</ul></li>
<li><a href="#ttfautohint-and-ttfautohintgui"><code>ttfautohint</code> and <code>ttfautohintGUI</code></a><ul>
<li><a href="#calling-ttfautohint">Calling <code>ttfautohint</code></a></li>
<li><a href="#calling-ttfautohintgui">Calling <code>ttfautohintGUI</code></a></li>
<li><a href="#options">Options</a><ul>
<li><a href="#hint-set-range-minimum-hint-set-range-maximum">Hint Set Range Minimum, Hint Set Range Maximum</a></li>
<li><a href="#fallback-script">Fallback Script</a></li>
<li><a href="#hinting-limit">Hinting Limit</a></li>
<li><a href="#x-height-increase-limit">x Height Increase Limit</a></li>
<li><a href="#x-height-snapping-exceptions">x Height Snapping Exceptions</a></li>
<li><a href="#windows-compatibility">Windows Compatibility</a></li>
<li><a href="#pre-hinting">Pre-Hinting</a></li>
<li><a href="#hint-with-components">Hint With Components</a></li>
<li><a href="#symbol-font">Symbol Font</a></li>
<li><a href="#dehint">Dehint</a></li>
<li><a href="#add-ttfautohint-info">Add ttfautohint Info</a></li>
<li><a href="#strong-stem-width-and-positioning">Strong Stem Width and Positioning</a></li>
<li><a href="#font-license-restrictions">Font License Restrictions</a></li>
<li><a href="#miscellaneous">Miscellaneous</a></li>
</ul></li>
</ul></li>
<li><a href="#background-and-technical-details">Background and Technical Details</a><ul>
<li><a href="#segments-and-edges">Segments and Edges</a></li>
<li><a href="#feature-analysis">Feature Analysis</a></li>
<li><a href="#blue-zones">Blue Zones</a></li>
<li><a href="#grid-fitting">Grid Fitting</a></li>
<li><a href="#hint-sets">Hint Sets</a></li>
<li><a href="#the-.ttfautohint-glyph">The ‘.ttfautohint’ Glyph</a></li>
<li><a href="#scripts">Scripts</a></li>
<li><a href="#sfnt-tables">SFNT Tables</a></li>
<li><a href="#problems">Problems</a></li>
</ul></li>
<li><a href="#the-ttfautohint-api">The ttfautohint API</a><ul>
<li><a href="#preprocessor-macros-and-typedefs">Preprocessor Macros and Typedefs</a></li>
<li><a href="#callback-ta_progress_func">Callback: <code>TA_Progress_Func</code></a></li>
<li><a href="#callback-ta_info_func">Callback: <code>TA_Info_Func</code></a></li>
<li><a href="#function-ttf_autohint">Function: <code>TTF_autohint</code></a><ul>
<li><a href="#io">I/O</a></li>
<li><a href="#messages-and-callbacks">Messages and Callbacks</a></li>
<li><a href="#general-hinting-options">General Hinting Options</a></li>
<li><a href="#hinting-algorithms">Hinting Algorithms</a></li>
<li><a href="#scripts-1">Scripts</a></li>
<li><a href="#miscellaneous-1">Miscellaneous</a></li>
<li><a href="#remarks">Remarks</a></li>
</ul></li>
</ul></li>
<li><a href="#compilation-and-installation">Compilation and Installation</a><ul>
<li><a href="#unix-platforms">Unix Platforms</a></li>
<li><a href="#ms-windows">MS Windows</a></li>
<li><a href="#mac-os-x">Mac OS X</a></li>
</ul></li>
<li><a href="#authors">Authors</a></li>
</ul>
</div>

</body>
</html>
